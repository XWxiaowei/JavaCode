## 异常断言和日志

### Java异常层次简要类图
### 何时声明受查异常
1. 调用一个抛出受查异常的方法，例如， FileInputStream构造器
2. 程序运行过程中发现错误，并且利用throw语句抛出一个受查异常
3. 程序出现错误，例如，a[-1]=0会抛出一个ArrayIndexOutOfBoundsException这样的非受查异常。
4. Java 虚拟机和运行时库出现的内部错误。

如果出现前两种情况之一，则必须告诉调用这个放啊的程序员有可能抛出异常。为什么？因为任何一个抛出异常的方法都可能是一个死亡陷阱。
如果没有处理器捕获这个异常，当前执行的线程就会结束。
如下所示：
```
  public Image loadImage(String s) throws IOException {
        return null;
    }
    
    public Image loadImage2(String s) throws FileNotFoundException,EOFException {
        return null;
    }

```
如果在子类中覆盖了超类的一个方法，**子类方法中声明的受查异常不能比超类方法中声明的异常更通用**（也就是说，子类方法中可以
抛出更特定的异常，或者根本不抛出任何异常）。特别需要说明的是，**如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常。**
### 自定义异常类
```
public class FileFormatException extends IOException {
    public FileFormatException() {

    }

    public FileFormatException(String msg) {
        super(msg);
    }

}

```
### 捕获异常
以下代码：
```
 FileInputStream in = new FileInputStream("test.txt");
        try {
            //1
//        code that might throw exception
            //2
        } catch (IOException e) {
           //3
            //show error message
            //4
        }
        finally {
            //5
            //in.close();
        }
        //6


```
有下列3中情况会执行finally子句
1. 代码没有抛出异常，在这种情况下，程序首先执行try语句块中的全部代码，然后执行finally子句
 中的代码，随后，继续执行try语句块之后的第一条语句。也就是说，执行顺序：1，2，5，6
2. 抛出一个在catch子句中捕获的异常。在上面的实例中就是IOException异常。在这种情况下，程序将
 执行try语句块中的所有代码，知道发生异常为止。此时，将跳过try语句块中的剩余代码，转去
 执行与该异常匹配的catch子句中的代码，最后执行finally子句中的代码。
 
   如果catch子句没有抛出异常，程序将执行try语句块之后的第一条语句，在这里，执行顺序：1，3，4，5，6

   如果catch子句抛出了一个异常，异常江北抛回这个方法的调用者。在这里，执行顺序是：1，3，5
3. 代码抛出了一个异常，但这个异常不是由catch子句捕获的。在这种情况下，程序将执行try语句块中的所有
语句，知道有异常被抛出位置。此时将跳过try语句块中的剩余代码，然后执行finally子句中的语句，并将异常抛给
这个方法的调用者，在这里，执行顺序：1，5

#### 强烈建议
强烈建议解耦合try/catch和try/finally语句块。这样可以提高代码的清晰度。例如：
```
   FileInputStream in = new FileInputStream("test.txt");
        try {
            try {
//        code that might throw exception
            } finally {
                in.close();
            }
        } catch (IOException e) {
            //show error message
        }

```
内层的try语句块只有一个职责，就是确保关闭输入流。外层的try语句块也只有一个职责，就是确保
报告出现的错误。这种设计方式不仅清楚，而且还具有一个功能，就是将会报告finally子句中出现的错误。
#### finally子句中也有返回的情况
```
public static void main(String[] args) {
        System.out.println("n=1时方法mult返回结果：" + mult(1));

        System.out.println("n=2时方法mult返回结果：" + mult(2));
    }

    public static int mult(int n) {
        try {
            int r = n * n;
            return r;
        } finally {
            if (n == 2) {
                return 0;
            }
        }
    }


```
得到结果是：
`n=1时方法mult返回结果：1
 n=2时方法mult返回结果：0
 `
 如结果所示，当n=2时，try语句块的计算结果为r=4,并执行return语句，然而，在方法
 真正返回值之前，还要执行finally子句。finally子句将使得方法的返回值为0，这个返回值会覆盖
 原始的返回值4。