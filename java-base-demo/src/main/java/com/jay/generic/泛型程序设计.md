## 泛型程序设计
      
### 第一节
1. 类型变量使用大写形式，且比较短，在Java库中，使用变量E表示集合的元素类型，K和V分别表示表的关键字与值得类型。Object 表示"任意类型"
2. 程序清单使用了Pair类，静态的minmax方法遍历了数组并同时计算出最大值和最小值。它用一个Pair对象返回了两个结果。
3. `compareTo` 方法只有 `Comparable` 接口有该方法，所以我们要将T限制为实现了`Comparable`接口的
的类
### 类型擦除
无论何时定义一个泛型类型，都自动提供了一个相应的原始类型，原始类型的名字就是删去参数后的泛型类型名，擦除类型变量，并替换为限定类型（无限定的变量用Object）
例如：Pair<T> 的原始类型如下所示：
```
public class Pair <Object>{
    private Object first;
    private Object second;

    public Object getFirst() {
        return first;
    }

    public void setFirst(Object first) {
        this.first = first;
    }

    public Object getSecond() {
        return second;
    }

    public void setSecond(Object second) {
        this.second = second;
    }

    public Pair(){}
    public Pair(Object first, Object second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public String toString() {
        return "Pair{" +
                "first=" + first +
                ", second=" + second +
                '}';
    }

```
类型擦除带来的方法参数不统一，编译器通过桥方法来处理。

### 与Java泛型转换的事实
 - 虚拟机中没有泛型，只有普通的类和方法。
 - 所有的类型参数都用它们的限定类型替换
 - 桥方法被合成来保持多态
 - 为保持类型安全性，必要时插入强制类型转换。
 
### 约束与局限性
1. 不能用基本类型实例化类型参数

例如没有 `Pair<double>`,只有 `Pair<Double>`

2. 运行时类型查询只适用于原始类型
例如：
```
Pair<String> stringPair=new Pair<String>();
Pair<Employee> employeePair=new Pair<Employee>();
if(stringPair.getClass()==employeePair.getClass())

```
其比较结果是true，这是因为两次调用getClass都将返回 Pair.class

3. 不能创建参数化类型的数组
例如：
`Pair<String>[] table=new Pair<String>[10]`  //error

4. Varargs 警告
```
public static <T> void addAll(Collection<T> coll,T ... ts){
    for(t: ts) coll.add(t);
}

```
现考虑以下调用：
```

Collection<Pair<String>> table=...;
Pair<String> pair1=...;
Pair<String> pair2=...;
Pair<String> pair3=...;
addAll(table,pair1,pair2);

```
 为了调用这个方法，Java虚拟机必须建立一个Pair<String> 数组。这就违反了前面的规则。
 不过，对于这种情况，规则有所放松，你只会得到一个警告，而不是错误。
 
 可以采取两种方法来抑制这个警告。一种方法是为包含addAll调用的方法增加注解@SuppressWarnings("unchecked")。或者在Java SE 7中，还
 可以用@SafeVarargs直接标注addAll方法。
 
 5 不能实例化类型变量
 不能使用像new T(...),new T[...] 或T.class 这样的表达式中的类型变量，例如下面
 Pair<T> 构造器就是非法的：
 `public Pair(){first=new T();second=new T();}`
 类型擦除将T改变成了Object,而且，其本意肯定不希望调用new Object()。在Java SE 8之后，最好的解决办法是让调用者
 提供一个构造器表达式。例如：
 `Pair<String> p=Pair.makePair(String::new)`
 6. 不能构造泛型数组
 例如：
 `public static <T extends Comparable> T[] minmax(T[] a){T[] mm=new T[2];} ` //error
 