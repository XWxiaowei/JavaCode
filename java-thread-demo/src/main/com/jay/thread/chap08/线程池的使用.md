一、**使用ThreadLocal的任务**。
    ThreadLocal使每个线程都可以拥有某个变量的一个私有"版本""，然而，只要条件允许，Executor可以自由地重用这些线程。
    在标准的Executor实现中，当执行需求较低时将回收空闲线程，而当需求增加是将添加新的线程，并且如果从任务中抛出生命周期
    受限于任务的生命周期时，在线程池的线程中使用ThreadLocal才有意义，而在线程池的线程中不应该使用ThreadLocal在任务之间传递值。
    
只有当任务都是同类型的并且相互独立时，线程池的性能才能达到最佳。如果将运行时间较长的与运行时间较短的任务混合在一起，那么除非
线程池很大，否则将可能造成""拥塞"。如果提交的任务依赖于其他任务，那么除非线程池无限大，否则将可能造成死锁。



  1、newFixedThreadPool  newFixedThreadPool将创建一个固定长度的线程池，每当提交一个任务是就创建一个线程，直到到达线程池的最大数量，这时线程池的规模将不再变化（如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新线程）

  2、newCachedThreadPool newCachedThreadPool将创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。
  
  3、newSingleThreadExcetor newSingleThreadExcetor是一个单线程的Executor,它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程替代，newSingleThreadExcetor能确保依照任务在队列中的顺序来串行执行。
  
  4、newScheduledThreadPool newScheduledThreadPool创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。

newFixedThreadPool工厂方法将线程池的基本大小和最大大小设置为参数中指定的值，而且创建的线程池不会超时，
newCachedThreadPool工厂方法将线程池的最大大小设置为Integer.MAX_VALUE,而将基本大小设置为零，并将超时设置为1分钟。
这种方法创建出来的线程池可以无限扩展，并且当需求降低时会自动收缩。其他形式的线程池可以通过显示地ThreadPoolExecutor
构造函数来构造

**饱和策略**
当有界队列被填满后，饱和策略开始发挥作用。ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改，JDK提供了几种不同的RejectedExecutionHandler
实现，每种是哪包含有不同的饱和策略：AbortPolicy,CallerRunsPolicy,DiscardPolicy和DiscardOldestPolicy.

"中止（Abort）" 策略是默认的饱和策略，该策略将抛出未检查的RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。
"调用者运行（Caller-Runs）" 策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。



如上图程序TimingThreadPool中给出了一个自定义的线程池，它通过beforeExecute、afterExecute和terminated等方法来添加日志记录
和统计信息收集。为了测量任务的运行时间，beforeExecute必须记录开始时间并将其保存到一个afterExecute可以访问的地方。因为这些方法将在
执行任务的线程中调用，因此beforeExecute可以把值保存到一个ThreadLocal变量中，然后由afterExecute来读取。在TimingThreadPool
中使用了AtomicLong变量，分别用于记录已处理的任务数和总的处理时间，并通过terminated来输出包含平均任务时间的日志消息