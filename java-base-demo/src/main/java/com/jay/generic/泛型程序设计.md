## 泛型程序设计
      
### 第一节
1. 类型变量使用大写形式，且比较短，在Java库中，使用变量E表示集合的元素类型，K和V分别表示表的关键字与值得类型。Object 表示"任意类型"
2. 程序清单使用了Pair类，静态的minmax方法遍历了数组并同时计算出最大值和最小值。它用一个Pair对象返回了两个结果。
3. `compareTo` 方法只有 `Comparable` 接口有该方法，所以我们要将T限制为实现了`Comparable`接口的
的类
### 类型擦除
无论何时定义一个泛型类型，都自动提供了一个相应的原始类型，原始类型的名字就是删去参数后的泛型类型名，擦除类型变量，并替换为限定类型（无限定的变量用Object）
例如：Pair<T> 的原始类型如下所示：
```
public class Pair <Object>{
    private Object first;
    private Object second;

    public Object getFirst() {
        return first;
    }

    public void setFirst(Object first) {
        this.first = first;
    }

    public Object getSecond() {
        return second;
    }

    public void setSecond(Object second) {
        this.second = second;
    }

    public Pair(){}
    public Pair(Object first, Object second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public String toString() {
        return "Pair{" +
                "first=" + first +
                ", second=" + second +
                '}';
    }

```
类型擦除带来的方法参数不统一，编译器通过桥方法来处理。

### 与Java泛型转换的事实
 - 虚拟机中没有泛型，只有普通的类和方法。
 - 所有的类型参数都用它们的限定类型替换
 - 桥方法被合成来保持多态
 - 为保持类型安全性，必要时插入强制类型转换。
 
### 约束与局限性
1. 不能用基本类型实例化类型参数
例如没有 `Pair<double>`,只有 `Pair<Double>`
2. 运行时类型查询只适用于原始类型

  