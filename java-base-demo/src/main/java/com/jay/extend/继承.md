## 继承
### this关键字的用途
1. 引用隐式参数；
2. 调用该类其他的构造器。
### super关键字的用途
1. 调用超类的方法。
2. 调用超类的构造器。

## 多态
可以通过 `is-a`规则，它表明子类的每个对象也是超类的对象。例如，每个
经理都是雇员。因此，将Manager类设计为Employee类的子类是显而易见的，反之不然，并不是每一名雇员都是经理。

`is-a` 规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。
例如：可以将一个子类的对象赋给超类变量
```
Employee e;
e=new Employee();
e=new Manager();

```
### 理解方法调用
弄清楚如何在对象上应用方法调用非常重要。下面假设要调用 `x.f(args)`,隐式参数x声明为类C的一个对象。下面是调用过程的详细描述：
1. 编译器查看对象的声明类型和方法名。
   
   假设调用 `x.f(args)`,且隐式参数x声明为C类的对象。需要注意的是：有可能存在多个名字为f，但参数类型不一样的方法。例如，可能存在
   方法 f(int)和方法f(String)。编译器将会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法。（超类的私有方法不可访问）
2. 编译器将查看调用方法时提供的参数类型。
  
    如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程称为**重载解析**。例如，对于调用 `x.f("HelloWorld")`
    来说，编译器将会挑选 `f(String)`,而不是 `f(int)` 。由于允许类型转换（int 可以转换成double,Manager可以转换成Employee,等等）,所以这个过程
    可能很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。
    
    至此，编译器已获得需要调用的方法名字和参数类型。
    
    **方法的名字和参数列表称为方法的签名，返回类型不是签名的一部分。**
3. 如果是Private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方法称为静态绑定。与此对应的是，
调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。在我们列举的示例中，编译器采用动态绑定的方式生成一条调用 `f(String)` 的指令。
    
4. 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。

   假设x的实际类型是D，它是C类的子类。如果D类定义了方法 `f(String)`,就直接调用它；否则，将在D类的超类中寻找 `f(String)`,
   
   每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表（method table）,其中列出了所有方法的签名和实际调用的方法。这样一来。
   在真正调用方法的时候，虚拟机仅查找这个表就行了。在前面的例子中。虚拟机搜索D类的方法表，以便寻找与调用 `f(String)` 相匹配的方法。这个方法既有可能是 `D.f(String)`,
   也有可能是 `X.f(String)`,这里的X是D的超类。这里需要提醒一点，如果调用 `super.f(param)`,编译器将对隐式超类的方法表进行搜索。
   
   现在，查看一下程序清单5-1中调用`e.getSalary()` 的详细过程。
   
   
   动态绑定有一个非常重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。假设增加一个新类 `Executive`,并且变量e有可能引用这个类的对象，我们不需要
   对包含调用 `e.getSalary()`的代码进行重新编译。如果e恰好引用一个Executive类的对象，就会自动地调用 `Executive.getSalary()`方法。
   
### 阻止继承：final类和方法

不允许扩展的类称为final类。
```
 public final class Executive extends Manager{
    ...
 }
```

   
